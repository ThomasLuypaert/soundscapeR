<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Acoustics.AED</name></assembly>
<members>
<member name="T:Acoustics.AED.Util.Px">
<summary>
 A unit of measure for a Pixel
</summary>
</member>
<member name="M:Acoustics.AED.GetAcousticEvents.spider(Microsoft.FSharp.Math.Matrix{System.Double},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Collections.FSharpSet{System.Tuple{System.Int32,System.Int32}})">
<summary>
 Spiders from an anchor. Returns all points that are connected.
 xs: anchors to check (recursive function multiplies with this list)
 WARNING, DANGER! m is mutated
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.DetectGroundParrots(System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}},System.Double)">
<summary>
 function: detectGroundParrots acousticEventsSequence   
</summary>
</member>
<member name="P:Acoustics.AED.EventPatternRecog.groundParrotTemplate">
<summary>
 current EPR is currently hardwirded to use only the groundParrotTemplate
 for detection
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.detect(Microsoft.FSharp.Collections.FSharpList{Acoustics.AED.Util.Rectangle{System.Double,System.Double}},System.Double,System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}})">
<summary>
 function: detect template minScore acousticEventsSequence
 Generic EPR detection function. Accepts a template for comparison, and a minimum score used as a threshold
 ---
 add dimensions to input
 let total = get the number of rects in template
 next, scoreEvents is run. the results are a seq&lt;float Rectangle * float&gt; (rects with score)
     a loop is run over the results
         any Rect whise score is greater then min result,
             has its value and a ?normalised? score yielded            
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.scoreEvents(System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}},System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}})">
<summary>
 function scoreEvents template acousticEvents
 ScoreEvents uses a template to score a list of acoustic events, 
 A list of candidates tupled with scores is returned.
 ---
 let (templateLeft, templateBottom, templateTimeDifference, templateFrequnecyRange) = ...
 let (xLength, yLength) = ... // number of pixels
 let ((templateCentroids:Seq&lt;float * float&gt;), (templateBottomLefts:Seq&lt;float * float&gt;)) = ... // values are normalised!
 function score restangles =
     let (startTime, startFrequency) = ... // of the candidates
     let (centroids, bottomLefts) = ... // normalised results!
         function f templateCentroid templateBottomLeft
             let index = given the centroids, find the distance between each point and given templateCentroid
                             then, select the index of the element with the shortest distance
             return overlap templateBottomLeft templateCentroid closest-Bottom-Left closest-Centroid
     Seq.map2 f templateCentroids templateBottomLefts // from parent function, map2 == normal map, but with two lists pair-wise
         |&gt; return sum of results

 let (?saes?, candidates) = candidates templateBottom templateTimeDimensions templateFrequencyRange acousticEventSequence
 Seq.zip saes (Seq.map score cs) // ACTUAL SCORING, pairs an ?acoustic event? with a ?candidate?
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.templateBounds(System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}})">
<summary>
 function: templateBounds template
 Returns the template&apos;s most left point, most bottom point, it&apos;s total width, and total height
 ---
	 let (templateLeft, templateBottom) = ...
  let (templateRight, templateTop) = ...
	 return tuple
	 	(templateLeft, templateBottom, width-of-template, height-of-template)
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.absLeftAbsBottom``2(System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{``0,``1}})">
<summary>
 function: absLeftAbsBottom rectangleSequence : Seq&lt;a&apos; Rectangle&gt; -&gt; a&apos; * a&apos;
 returns the most leftest and bottomest point from a seq&lt;&apos;a rectangle&gt;
 ---
	 return tuple of
		(minmap left rs, minmap bottom rs) // min map applies function to each rect to select dimension to use    
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.pixelAxisLengths(System.Double,System.Double)">
<summary>
 function pixelAxisLengths templateimeDifference templateFrequency: float -&gt; float -&gt; (float * float)
 Length of x and y axis&apos; to scale time and frequency back to.
 Returns the number of pixels occupied by the specified time/frequency domain and
 ---
 return tuple of 
     templateimeDifference / (freqBins / samplingRate),   // e.g. 120 / (256 / 22050) = 10335 |&gt; 10336
     templateFrequency / freqMax * (freqBins - 1.0)  //e.g. 11025 / 22050 * (255) = 0.0??
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.overlap``2(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
 function overlap (templateLeft, templateBottom) (templateCentroidTime, templateCentroidFrequency) (left, bottom) (centroidLeft, centroidFrequency)
 Calculates an overlap. Returns a dimensionless float    
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.euclidianDist``10(Microsoft.FSharp.Core.FSharpFunc{``8,``9},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``8}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``3}},Microsoft.FSharp.Core.FSharpFunc{``5,Microsoft.FSharp.Core.FSharpFunc{``5,``4}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``6,Microsoft.FSharp.Core.FSharpFunc{``7,``5}},``0,``6,``1,``7)">
<summary>
 Returns distance between two points
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.centroidsBottomLefts(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{Acoustics.AED.Util.Rectangle{System.Double,System.Double}})">
<summary>
 function centroidsBottomLefts startTime startFrequency timeDifference frequencyRange normalisedTime normalisedFrequency rectangles
 Returns a Seq of centroids, tupled with a Seq of bottom-lefts both obtained from rs.
 Both are results are normalised (i.e. they are pixels).
 ---
 return tuple
     apply centroids func to rs |&gt; then normalise results?
     apply bottomLeft func to each element to rs |&gt; normalize results?
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.centre``1(System.Double,System.Double)">
<summary>
 calculate centre point from rect
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.normaliseTimeFreq(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
function: normaliseTimeFreq starttime startfreq timeDifferance frequencyRange normalisedTime normalisedFrequency (timeToNormalise, frequencyToNormalise)? : float -&gt; float -&gt; float -&gt; float -&gt; float -&gt; float -&gt;  (float * float) -&gt; (float * float) 
 Normalises a given time/frequency tuple.
 ---
	function g x start differance ?length? : float -&gt; float -&gt; float -&gt; float -&gt; float 
		let x&apos; =  round( x - s / d * l)  // get rid of start from x, don&apos;t get d*l???
			in if x&apos; &lt; 1.0 then
					1.0
				else if x&apos; &gt; l then
					l
				else 
					x&apos;
		// then, apply g twice in tuple, once each for time and frequency
		(g t startTime timedimensions nt, g f startfrequency frequencyrange nf) 
</summary>
</member>
<member name="M:Acoustics.AED.EventPatternRecog.EprInternals.indexMinMap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 function: indexMinMap f xs :  (&apos;a -&gt; &apos;b) -&gt; seq&lt;&apos;a&gt; -&gt; int
 Runs f over sequence xs, then returns index of lowest value returned from f.
</summary>
</member>
</members>
</doc>
